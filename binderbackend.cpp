#include <string>
#include "codearray.h" // source of our executables.
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h> // execlp, fork
#include <sys/wait.h>
#include <vector>
#include <sys/stat.h>
#include <sys/types.h>
#include <iostream>

using namespace std;

int main()
{

	/* The child process id */
	pid_t childProcId = -1;

	/* Go through the binaries */

	for(int progIndex = 0; 	progIndex < NUM_BINARIES; ++progIndex)
	{

		// Create a temporary file you can use the tmpnam() function for this.
		// "If the argument is NULL, this name is generated in an internal static buffer and may be overwritten by the next call to tmpnam()" Is this what we want?
		char* progName = tmpnam(NULL);

		// Create a file with the name generated by tmpnam.
		FILE* progFile = fopen(progName, "w");

		// These bytes are found in codeArray[progIndex] in the header file.
		// Write the bytes of the first program to the file.
		for(int byteIndex = 0; byteIndex < progLens[progIndex]; byteIndex++)
		{
			fputc(codeArray[progIndex][byteIndex], progFile);
		}

		// make the file executable.
	  chmod(progName, 0777);

		// close the file, we are done writing to it.
		fclose(progFile);

		// fork a child proc and save the id. child proccess id should be be 0.
		childProcId = fork();

		/* I am a child process; I will turn into an executable */
		if(childProcId == 0)
		{
				// turn the child into an executable. send the execute function the path and name of the executable file we made.
				if( -1 == execlp(progName, NULL) )
				{
						printf("Error Executing: %s", progName);
				}
		}
	}

	/* Wait for all programs to finish */
	for(int progIndex = 0; progIndex < NUM_BINARIES; ++progIndex)
	{
		/* Wait for one of the programs to finish */
		if(wait(NULL) < 0)
		{
			perror("wait");
			exit(-1);
		}
	}

	return 0;
}
